% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/NN equating functions.R
\name{EquateNN}
\alias{EquateNN}
\title{Experimental technique to equate using a pre-trained neural network}
\usage{
EquateNN(dx, dy, anchortargettable, maxx = NA, maxy = NA, maxa = NA,
  WeightsList = EquateNNWeights)
}
\arguments{
\item{dx}{Data frame with variables "x" and "a" representing scores for individual candidates on form X and on the anchor test.}

\item{dy}{Data frame with variables "y" and "a" representing scores for individual candidates on form Y and on the anchor test.}

\item{anchortargettable}{Table giving distribution of anchor test scores in the target population.}

\item{maxx}{Maximum score available on form X (calculated from the data by default).}

\item{maxy}{Maximum score available on form Y (calculated from the data by default).}

\item{maxa}{Maximum score available on anchor test (calculated from the data by default).}

\item{WeightsList}{A list of neural network parameters used in calculations. Changing this from the default value is not recommended.}
}
\value{
The function returns a list with two elements.
\describe{
  \item{CNNEqFunc}{A function that translates any vector of scores on form X (from 0-maxx) into equivalent scores on form Y.}
  \item{EqTable}{A data frame combining scores from 0-maxx in the data and their equated values on form Y.}}
}
\description{
This function is designed to work in the NEAT equating design.
It assumes all scores are integers and that it is an EXTERNAL anchor test.
}
\examples{
#example where we simulate scores on two parallel tests in two populations using classical test theory
n1=400
n2=300
t1=rnorm(n1,0.5,1)
t2=rnorm(n2,0,1)
dx1=data.frame(x=round(pmin(100,pmax(0,50+20*(0.9*t1+rnorm(n1,0,sqrt(1-0.9^2)))))),
	a=round(pmin(20,pmax(0,10+4*(0.7*t1+rnorm(n1,0,sqrt(1-0.7^2)))))))
dy1=data.frame(y=round(pmin(100,pmax(0,50+20*(0.9*t2+rnorm(n2,0,sqrt(1-0.9^2))))))
	,a=round(pmin(20,pmax(0,10+4*(0.7*t2+rnorm(n2,0,sqrt(1-0.7^2)))))))
NNeq1=EquateNN(dx1,dy1,table(dy1$a))
chainedeq1=KernelChainedEquate(dx1, dy1)$EqTable
pseeq1=PSEObservedEquate(dx1, dy1, target = "y")$EqTable
plot(chainedeq1$x,chainedeq1$equiyx,type='l')#chained equating function
lines(pseeq1$x,pseeq1$equiyx,lty=3,col="red")#PSE estimated equating function
lines(NNeq1$EqTable$x,NNeq1$EqTable$yx,lty=2)#NN estimated equating function
lines(0:100,0:100,col="blue",lty=3,lwd=4)#true equating function (identity as set up to be parallel tests)

#example using some real data (but no criterion equate to compare to)
dx2=data.frame(x=rowSums(mathsdata[1:250,1:35]),a=rowSums(mathsdata[1:250,41:50]))
summary(dx2)
dy2=data.frame(y=rowSums(mathsdata[251:500,51:90]),a=rowSums(mathsdata[251:500,41:50]))
summary(dy2)
NNeq2=EquateNN(dx2,dy2,table(dy1$a))
chainedeq=KernelChainedEquate(dx2, dy2)$EqTable
plot(chainedeq$x,chainedeq$equiyx,type='l')#chained equating function
lines(NNeq2$EqTable$x,NNeq2$EqTable$yx,lty=2)#NN estimated equating function

}
